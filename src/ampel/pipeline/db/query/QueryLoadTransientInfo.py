#!/usr/bin/env python
# -*- coding: utf-8 -*-
# File              : ampel/pipeline/db/query/QueryLoadTransientInfo.py
# License           : BSD-3-Clause
# Author            : vb <vbrinnel@physik.hu-berlin.de>
# Date              : 14.02.2018
# Last Modified Date: 28.05.2018
# Last Modified By  : vb <vbrinnel@physik.hu-berlin.de>

from ampel.flags.AlDocTypes import AlDocTypes
from ampel.flags.FlagUtils import FlagUtils
from ampel.pipeline.db.query.QueryMatchCriteria import QueryMatchCriteria


class QueryLoadTransientInfo:
	"""
	"""

	limited_altypes = (
		AlDocTypes.COMPOUND,
		AlDocTypes.TRANSIENT
	)

	@staticmethod
	def build_stateless_query(tran_ids, content_types, channels=None, t2_ids=None):
		"""
		-> Loads transient info (not including photpoints/upper limits which are in a separate collection).
		-> Stateless query: all compounds and (possible t2_ids limited) t2docs to be retrieved.

		Arguments:
		----------
		* tran_id: transient id(s) (int, list of ints, set of ints). 
		  Query can be built so that it is performed on multiple ids at once.

		* channels: can be a flag, a list of flags, a string, a list of strings, a 2d list of strings:
		  -> flags:
			- either an instance of ChannelFlags (dynamically generated by FlagGenerator)
			    * the flags contained in each instance are 'AND' connected
			- or list of instances of ChannelFlags 
				* whereby the list elements are OR connected 

		  -> strings:
			- a list of strings (whereby string = channel id)
			- a 2d list of strings 
				* outer list: flag ids connected by OR
				* innerlist: flag ids connected by AND

		* content_types: instance of AlDocTypes. 
		  AlDocTypes.PHOTOPOINT and AlDocTypes.UPPERLIMIT will be ignored

		* t2_ids: list of t2 unit ids (string). 
		  If None, all associated t2 docs will be loaded
		"""

		match_dict = {}

		match_dict['tranId'] = ( 
			tran_ids if type(tran_ids) is int
			else {'$in': tran_ids if type(tran_ids) is list else list(tran_ids)}
		)

		if channels is not None:
			QueryMatchCriteria.add_from_list(
				match_dict, 'channels',
				(channels if not FlagUtils.contains_enum_flag(channels) 
				else FlagUtils.enum_flags_to_lists(channels)), 
			)

		# Everything should be retrieved (AlDocTypes: 1+2+4+8=15)
		if t2_ids is None and content_types.value == 15:
			return match_dict

		# Build array of AlDocTypes (AlDocTypes.T2RECORD will be set later since it depends in t2_ids)
		al_types = [
			al_type for al_type in QueryLoadTransientInfo.limited_altypes 
			if al_type in content_types
		]

		if t2_ids is None:

			# Complete alDocType with type T2RECORD if so wished
			if AlDocTypes.T2RECORD in content_types:
				al_types.append(AlDocTypes.T2RECORD)

			match_dict['alDocType'] = (
				al_types[0] if len(al_types) == 1 
				else {'$in': al_types}
			)

			# return query matching criteria
			return match_dict

		else:

			# Combine first part of query (transient+compounds) 
			# with t2UnitId targeted T2RECORD query
			match_dict['$or'] = [
				# transient+compounds 
				{
					'alDocType': (
						al_types[0] if len(al_types) == 1 
						else {'$in': al_types}
					)
				},
				# t2s
				{
					'alDocType': AlDocTypes.T2RECORD,
					't2Unit': t2_ids if type(t2_ids) is str else (
						t2_ids[0] if len(t2_ids) == 1 else {'$in': t2_ids}
					)
				}
			]

		return match_dict


	@staticmethod
	def build_statebound_query(
		tran_ids, content_types, compound_ids, 
		channels=None, t2_ids=None, comp_already_loaded=False
	):
		"""
		"""

		# Logic check
		if AlDocTypes.COMPOUND not in content_types and AlDocTypes.T2RECORD not in content_types :
			raise ValueError(
				"State scoped queries make no sense without either AlDocTypes.COMPOUND " +
				"or AlDocTypes.T2RECORD set in content_types"
			)

		match_dict = {}

		match_dict['tranId'] = ( 
			tran_ids if type(tran_ids) is int
			else {'$in': tran_ids if type(tran_ids) is list else list(tran_ids)}
		)

		if channels is not None:
			QueryMatchCriteria.add_from_list(
				match_dict, 'channels',
				(channels if not FlagUtils.contains_enum_flag(channels) 
				else FlagUtils.enum_flags_to_lists(channels)), 
			)

		match_comp_ids = (
			compound_ids if type(compound_ids) is str
			else ( # should be list
				compound_ids[0] if len(compound_ids) == 1 
				else {'$in': compound_ids}
			)
		)

		# build query with 'or' connected search criteria
		or_list = []

		if AlDocTypes.TRANSIENT in content_types:

			or_list.append(
				{'alDocType': AlDocTypes.TRANSIENT}
			)

		if AlDocTypes.COMPOUND in content_types and comp_already_loaded is False:

			or_list.append(
				{
					'alDocType': AlDocTypes.COMPOUND, 
					'_id': match_comp_ids	
				}
			)

		if AlDocTypes.T2RECORD in content_types:

			t2_match = {
				'alDocType': AlDocTypes.T2RECORD, 
				'compoundId': match_comp_ids
			}

			if t2_ids is not None:
				t2_match['t2Unit'] = (
					t2_ids if type(t2_ids) is str 
					else (
						t2_ids[0] if len(t2_ids) == 1 
						else {'$in': t2_ids}
					)
				)

			or_list.append(t2_match)

		# If only 1 $or criteria was generated, then 
		# just add this criteria to the root dict ('and' connected with tranId: ...)
		if len(or_list) == 1:
			el = or_list[0]
			for key in el.keys():
				match_dict[key] = el[key]
		else:
			match_dict['$or'] = or_list

		return match_dict
